{
  "language": "Solidity",
  "sources": {
    "contracts/factory/DSPFactory.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {InitializableOwnable} from \"../libraries/InitializableOwnable.sol\";\r\nimport {ICloneFactory} from \"../libraries/CloneFactory.sol\";\r\nimport {IDSP} from \"../stablePool/interfaces/IDSP.sol\";\r\n\r\ninterface IDSPFactory {\r\n    function createStablePool(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external returns (address newStablePool);\r\n}\r\n\r\n/**\r\n * @title StablePool Factory\r\n *\r\n * @notice Create And Register DSP Pools\r\n */\r\ncontract DSPFactory is InitializableOwnable {\r\n    // ============ Templates ============\r\n\r\n    address public immutable _CLONE_FACTORY_;\r\n    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\r\n    address public _DEFAULT_MAINTAINER_;\r\n    address public _DSP_TEMPLATE_;\r\n\r\n    // ============ Registry ============\r\n\r\n    // base -> quote -> DSP address list\r\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\r\n    // creator -> DSP address list\r\n    mapping(address => address[]) public _USER_REGISTRY_;\r\n\r\n    // ============ Events ============\r\n\r\n    event NewDSP(address baseToken, address quoteToken, address creator, address DSP);\r\n\r\n    event RemoveDSP(address DSP);\r\n\r\n    // ============ Functions ============\r\n\r\n    constructor(\r\n        address cloneFactory,\r\n        address DSPTemplate,\r\n        address defaultMaintainer,\r\n        address defaultMtFeeRateModel\r\n    ) public {\r\n        _CLONE_FACTORY_ = cloneFactory;\r\n        _DSP_TEMPLATE_ = DSPTemplate;\r\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\r\n        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\r\n    }\r\n\r\n    function createStablePool(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external returns (address newStablePool) {\r\n        newStablePool = ICloneFactory(_CLONE_FACTORY_).clone(_DSP_TEMPLATE_);\r\n        {\r\n            IDSP(newStablePool).init(\r\n                _DEFAULT_MAINTAINER_,\r\n                baseToken,\r\n                quoteToken,\r\n                lpFeeRate,\r\n                _DEFAULT_MT_FEE_RATE_MODEL_,\r\n                i,\r\n                k,\r\n                isOpenTWAP\r\n            );\r\n        }\r\n        _REGISTRY_[baseToken][quoteToken].push(newStablePool);\r\n        _USER_REGISTRY_[tx.origin].push(newStablePool);\r\n        emit NewDSP(baseToken, quoteToken, tx.origin, newStablePool);\r\n    }\r\n\r\n    // ============ Admin Operation Functions ============\r\n\r\n    function updateDSPTemplate(address _newDSPTemplate) external onlyOwner {\r\n        _DSP_TEMPLATE_ = _newDSPTemplate;\r\n    }\r\n\r\n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\r\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\r\n    }\r\n\r\n    function addPoolByAdmin(\r\n        address creator,\r\n        address baseToken,\r\n        address quoteToken,\r\n        address pool\r\n    ) external onlyOwner {\r\n        _REGISTRY_[baseToken][quoteToken].push(pool);\r\n        _USER_REGISTRY_[creator].push(pool);\r\n        emit NewDSP(baseToken, quoteToken, creator, pool);\r\n    }\r\n\r\n    function removePoolByAdmin(\r\n        address creator,\r\n        address baseToken,\r\n        address quoteToken,\r\n        address pool\r\n    ) external onlyOwner {\r\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\r\n        for (uint256 i = 0; i < registryList.length; i++) {\r\n            if (registryList[i] == pool) {\r\n                registryList[i] = registryList[registryList.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        _REGISTRY_[baseToken][quoteToken] = registryList;\r\n        _REGISTRY_[baseToken][quoteToken].pop();\r\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\r\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\r\n            if (userRegistryList[i] == pool) {\r\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        _USER_REGISTRY_[creator] = userRegistryList;\r\n        _USER_REGISTRY_[creator].pop();\r\n        emit RemoveDSP(pool);\r\n    }\r\n\r\n    // ============ View Functions ============\r\n\r\n    function getPairPool(address baseToken, address quoteToken)\r\n        external\r\n        view\r\n        returns (address[] memory machines)\r\n    {\r\n        return _REGISTRY_[baseToken][quoteToken];\r\n    }\r\n\r\n    function getPairPoolBidirection(address token0, address token1)\r\n        external\r\n        view\r\n        returns (address[] memory baseToken0Machines, address[] memory baseToken1Machines)\r\n    {\r\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\r\n    }\r\n\r\n    function getPairPoolByUser(address user) external view returns (address[] memory machines) {\r\n        return _USER_REGISTRY_[user];\r\n    }\r\n}\r\n"
    },
    "contracts/factory/DVMFactory.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {InitializableOwnable} from \"../libraries/InitializableOwnable.sol\";\r\nimport {ICloneFactory} from \"../libraries/CloneFactory.sol\";\r\nimport {IDVM} from \"../vendingMachine/interfaces/IDVM.sol\";\r\n\r\ninterface IDVMFactory {\r\n    function createVendingMachine(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external returns (address newVendingMachine);\r\n}\r\n\r\n\r\n/**\r\n * @title VendingMachine Factory\r\n *\r\n * @notice Create And Register DVM Pools \r\n */\r\ncontract DVMFactory is InitializableOwnable {\r\n    // ============ Templates ============\r\n\r\n    address public immutable _CLONE_FACTORY_;\r\n    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\r\n    address public _DEFAULT_MAINTAINER_;\r\n    address public _DVM_TEMPLATE_;\r\n\r\n    // ============ Registry ============\r\n\r\n    // base -> quote -> DVM address list\r\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\r\n    // creator -> DVM address list\r\n    mapping(address => address[]) public _USER_REGISTRY_;\r\n\r\n    // ============ Events ============\r\n\r\n    event NewDVM(\r\n        address baseToken,\r\n        address quoteToken,\r\n        address creator,\r\n        address dvm\r\n    );\r\n\r\n    event RemoveDVM(address dvm);\r\n\r\n    // ============ Functions ============\r\n\r\n    constructor(\r\n        address cloneFactory,\r\n        address dvmTemplate,\r\n        address defaultMaintainer,\r\n        address defaultMtFeeRateModel\r\n    ) public {\r\n        _CLONE_FACTORY_ = cloneFactory;\r\n        _DVM_TEMPLATE_ = dvmTemplate;\r\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\r\n        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\r\n    }\r\n\r\n    function createVendingMachine(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external returns (address newVendingMachine) {\r\n        newVendingMachine = ICloneFactory(_CLONE_FACTORY_).clone(_DVM_TEMPLATE_);\r\n        {\r\n            IDVM(newVendingMachine).init(\r\n                _DEFAULT_MAINTAINER_,\r\n                baseToken,\r\n                quoteToken,\r\n                lpFeeRate,\r\n                _DEFAULT_MT_FEE_RATE_MODEL_,\r\n                i,\r\n                k,\r\n                isOpenTWAP\r\n            );\r\n        }\r\n        _REGISTRY_[baseToken][quoteToken].push(newVendingMachine);\r\n        _USER_REGISTRY_[tx.origin].push(newVendingMachine);\r\n        emit NewDVM(baseToken, quoteToken, tx.origin, newVendingMachine);\r\n    }\r\n\r\n    // ============ Admin Operation Functions ============\r\n\r\n    function updateDvmTemplate(address _newDVMTemplate) external onlyOwner {\r\n        _DVM_TEMPLATE_ = _newDVMTemplate;\r\n    }\r\n    \r\n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\r\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\r\n    }\r\n\r\n    function addPoolByAdmin(\r\n        address creator,\r\n        address baseToken, \r\n        address quoteToken,\r\n        address pool\r\n    ) external onlyOwner {\r\n        _REGISTRY_[baseToken][quoteToken].push(pool);\r\n        _USER_REGISTRY_[creator].push(pool);\r\n        emit NewDVM(baseToken, quoteToken, creator, pool);\r\n    }\r\n\r\n    function removePoolByAdmin(\r\n        address creator,\r\n        address baseToken, \r\n        address quoteToken,\r\n        address pool\r\n    ) external onlyOwner {\r\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\r\n        for (uint256 i = 0; i < registryList.length; i++) {\r\n            if (registryList[i] == pool) {\r\n                registryList[i] = registryList[registryList.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        _REGISTRY_[baseToken][quoteToken] = registryList;\r\n        _REGISTRY_[baseToken][quoteToken].pop();\r\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\r\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\r\n            if (userRegistryList[i] == pool) {\r\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        _USER_REGISTRY_[creator] = userRegistryList;\r\n        _USER_REGISTRY_[creator].pop();\r\n        emit RemoveDVM(pool);\r\n    }\r\n\r\n    // ============ View Functions ============\r\n\r\n    function getPairPool(address baseToken, address quoteToken)\r\n        external\r\n        view\r\n        returns (address[] memory machines)\r\n    {\r\n        return _REGISTRY_[baseToken][quoteToken];\r\n    }\r\n\r\n    function getPairPoolBidirection(address token0, address token1)\r\n        external\r\n        view\r\n        returns (address[] memory baseToken0Machines, address[] memory baseToken1Machines)\r\n    {\r\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\r\n    }\r\n\r\n    function getPairPoolByUser(address user)\r\n        external\r\n        view\r\n        returns (address[] memory machines)\r\n    {\r\n        return _USER_REGISTRY_[user];\r\n    }\r\n}\r\n"
    },
    "contracts/helper/WorldesRouterHelper.sol": {
      "content": "/*\r\n\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IWorldes} from \"../interfaces/IWorldes.sol\";\r\nimport {InitializableOwnable} from \"../libraries/InitializableOwnable.sol\";\r\n\r\ncontract WorldesRouterHelper is InitializableOwnable {\r\n    address public immutable _DVM_FACTORY_;\r\n    address public immutable _DSP_FACTORY_;\r\n\r\n    // base -> quote -> address list\r\n    mapping(address => mapping(address => address[])) public _FILTER_POOLS_;\r\n\r\n    struct PairDetail {\r\n        uint256 i;\r\n        uint256 K;\r\n        uint256 B;\r\n        uint256 Q;\r\n        uint256 B0;\r\n        uint256 Q0;\r\n        uint256 R;\r\n        uint256 lpFeeRate;\r\n        uint256 mtFeeRate;\r\n        address baseToken;\r\n        address quoteToken;\r\n        address curPair;\r\n        uint256 pairVersion;\r\n    }\r\n\r\n    constructor(address dvmFactory,address dspFactory) public {\r\n        _DVM_FACTORY_ = dvmFactory;\r\n        _DSP_FACTORY_ = dspFactory;\r\n    }\r\n\r\n    function getPairDetail(address token0,address token1,address userAddr) external view returns (PairDetail[] memory res) {\r\n        address[] memory baseToken0DVM;\r\n        address[] memory baseToken1DVM;\r\n        address[] memory baseToken0DSP;\r\n        address[] memory baseToken1DSP;\r\n\r\n        if(_FILTER_POOLS_[token0][token1].length > 0) {\r\n            baseToken0DVM = _FILTER_POOLS_[token0][token1];\r\n        } \r\n\r\n        else if(_FILTER_POOLS_[token1][token0].length > 0) {\r\n            baseToken1DVM = _FILTER_POOLS_[token1][token0];\r\n        }\r\n        \r\n        else {\r\n            (baseToken0DVM, baseToken1DVM) = IWorldes(_DVM_FACTORY_).getPairPoolBidirection(token0,token1);\r\n            (baseToken0DSP, baseToken1DSP) = IWorldes(_DSP_FACTORY_).getPairPoolBidirection(token0,token1);\r\n        }\r\n\r\n        uint256 len = baseToken0DVM.length + baseToken1DVM.length + baseToken0DSP.length + baseToken1DSP.length;\r\n        res = new PairDetail[](len);\r\n        for(uint8 i = 0; i < len; i++) {\r\n            PairDetail memory curRes = PairDetail(0,0,0,0,0,0,0,0,0,address(0),address(0),address(0),2);\r\n            address cur;\r\n            if(i < baseToken0DVM.length) {\r\n                cur = baseToken0DVM[i];\r\n                curRes.baseToken = token0;\r\n                curRes.quoteToken = token1;\r\n            } else if(i < baseToken0DVM.length + baseToken1DVM.length) {\r\n                cur = baseToken1DVM[i - baseToken0DVM.length];\r\n                curRes.baseToken = token1;\r\n                curRes.quoteToken = token0;\r\n            } else if(i < baseToken0DVM.length + baseToken1DVM.length + baseToken0DSP.length)  {\r\n                cur = baseToken0DSP[i - baseToken0DVM.length - baseToken1DVM.length];\r\n                curRes.baseToken = token0;\r\n                curRes.quoteToken = token1;\r\n            } else {\r\n                cur = baseToken1DSP[i - baseToken0DVM.length - baseToken1DVM.length - baseToken0DSP.length];\r\n                curRes.baseToken = token1;\r\n                curRes.quoteToken = token0;\r\n            }\r\n\r\n            try IWorldes(cur).getPMMStateForCall() returns (uint256 _i, uint256 _K, uint256 _B, uint256 _Q, uint256 _B0, uint256 _Q0, uint256 _R){                  \r\n                curRes.i = _i;\r\n                curRes.K = _K;\r\n                curRes.B = _B;\r\n                curRes.Q = _Q;\r\n                curRes.B0 = _B0;\r\n                curRes.Q0 = _Q0;\r\n                curRes.R = _R;\r\n            } catch {\r\n                continue;\r\n            }\r\n            \r\n            try IWorldes(cur).getUserFeeRate(userAddr) returns  (uint256 lpFeeRate, uint256 mtFeeRate) {\r\n                (curRes.lpFeeRate, curRes.mtFeeRate) = (lpFeeRate, mtFeeRate);\r\n            } catch {\r\n                (curRes.lpFeeRate, curRes.mtFeeRate) = (0, 1e18);\r\n            }  \r\n            curRes.curPair = cur;\r\n            res[i] = curRes;\r\n        }\r\n    }\r\n\r\n\r\n    function batchAddPoolByAdmin(\r\n        address[] memory baseTokens, \r\n        address[] memory quoteTokens,\r\n        address[] memory pools\r\n    ) external onlyOwner {\r\n        require(baseTokens.length == quoteTokens.length,\"PARAMS_INVALID\");\r\n        require(baseTokens.length == pools.length,\"PARAMS_INVALID\");\r\n        for(uint256 i = 0; i < baseTokens.length; i++) {\r\n            address baseToken = baseTokens[i];\r\n            address quoteToken = quoteTokens[i];\r\n            address pool = pools[i];\r\n            \r\n            _FILTER_POOLS_[baseToken][quoteToken].push(pool);\r\n        }\r\n    }\r\n\r\n    function removePoolByAdmin(\r\n        address baseToken, \r\n        address quoteToken,\r\n        address pool\r\n    ) external onlyOwner {\r\n        address[] memory pools = _FILTER_POOLS_[baseToken][quoteToken];\r\n        for (uint256 i = 0; i < pools.length; i++) {\r\n            if (pools[i] == pool) {\r\n                pools[i] = pools[pools.length - 1];\r\n                break;\r\n            }\r\n        }\r\n        _FILTER_POOLS_[baseToken][quoteToken] = pools;\r\n        _FILTER_POOLS_[baseToken][quoteToken].pop();\r\n    }\r\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// This is a file copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IWETH {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 wad\r\n    ) external returns (bool);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n"
    },
    "contracts/interfaces/IWorldes.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IWorldes {\r\n\r\n    //========== Common ==================\r\n\r\n    function sellBase(address to) external returns (uint256 receiveQuoteAmount);\r\n\r\n    function sellQuote(address to) external returns (uint256 receiveBaseAmount);\r\n\r\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\r\n\r\n    function _BASE_TOKEN_() external view returns (address);\r\n\r\n    function _QUOTE_TOKEN_() external view returns (address);\r\n\r\n    function getPMMStateForCall() external view returns (\r\n            uint256 i,\r\n            uint256 K,\r\n            uint256 B,\r\n            uint256 Q,\r\n            uint256 B0,\r\n            uint256 Q0,\r\n            uint256 R\r\n    );\r\n\r\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);\r\n\r\n    \r\n    function getPairPoolBidirection(address token0, address token1) external view returns (address[] memory, address[] memory);\r\n\r\n    //========== VendingMachine ========\r\n    \r\n    function createVendingMachine(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external returns (address newVendingMachine);\r\n    \r\n    function buyShares(address to) external returns (uint256,uint256,uint256);\r\n\r\n    function bid(address to) external;\r\n}"
    },
    "contracts/interfaces/IWorldesApprove.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\n\r\ninterface IWorldesApprove {\r\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\r\n    function getWorldesProxy() external view returns (address);\r\n}\r\n"
    },
    "contracts/interfaces/IWorldesCallee.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IWorldesCallee {\r\n    function DVMSellShareCall(\r\n        address sender,\r\n        uint256 burnShareAmount,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DVMFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DSPFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IWorldesDvmProxy.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IWorldesDvmProxy {\r\n    function worldesSwapETHToToken(\r\n        address toToken,\r\n        uint256 minReturnAmount,\r\n        address[] memory worldesPairs,\r\n        uint256 directions,\r\n        uint256 deadLine\r\n    ) external payable returns (uint256 returnAmount);\r\n\r\n    function worldesSwapTokenToETH(\r\n        address fromToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory worldesPairs,\r\n        uint256 directions,\r\n        uint256 deadLine\r\n    ) external returns (uint256 returnAmount);\r\n\r\n    function worldesSwapTokenToToken(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory worldesPairs,\r\n        uint256 directions,\r\n        uint256 deadLine\r\n    ) external returns (uint256 returnAmount);\r\n\r\n    function createVendingMachine(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP,\r\n        uint256 deadLine\r\n    ) external payable returns (address newVendingMachine, uint256 shares);\r\n\r\n    function addDVMLiquidity(\r\n        address dvmAddress,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        uint8 flag, //  0 - ERC20, 1 - baseInETH, 2 - quoteInETH\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 shares,\r\n            uint256 baseAdjustedInAmount,\r\n            uint256 quoteAdjustedInAmount\r\n        );\r\n\r\n    function externalSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        address approveTarget,\r\n        address to,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        bytes memory callDataConcat,\r\n        uint256 deadLine\r\n    ) external payable returns (uint256 returnAmount);\r\n}\r\n"
    },
    "contracts/libraries/CloneFactory.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ICloneFactory {\r\n    function clone(address prototype) external returns (address proxy);\r\n}\r\n\r\n// introduction of proxy mode design: https://docs.openzeppelin.com/upgrades/2.8/\r\n// minimum implementation of transparent proxy: https://eips.ethereum.org/EIPS/eip-1167\r\n\r\ncontract CloneFactory is ICloneFactory {\r\n    function clone(address prototype) external override returns (address proxy) {\r\n        bytes20 targetBytes = bytes20(prototype);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(\r\n                add(clone, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            proxy := create(0, clone, 0x37)\r\n        }\r\n        return proxy;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/DecimalMath.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {SafeMath} from \"./SafeMath.sol\";\r\n\r\n/**\r\n * @title DecimalMath\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n\r\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\r\n        if (e == 0) {\r\n            return 10 ** 18;\r\n        } else if (e == 1) {\r\n            return target;\r\n        } else {\r\n            uint p = powFloor(target, e.div(2));\r\n            p = p.mul(p) / (10**18);\r\n            if (e % 2 == 1) {\r\n                p = p.mul(target) / (10**18);\r\n            }\r\n            return p;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/FeeRateModel.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {InitializableOwnable} from \"../libraries/InitializableOwnable.sol\";\r\n\r\ninterface IFeeRateImpl {\r\n    function getFeeRate(address pool, address trader) external view returns (uint256);\r\n}\r\n\r\ninterface IFeeRateModel {\r\n    function getFeeRate(address trader) external view returns (uint256);\r\n}\r\n\r\ncontract FeeRateModel is InitializableOwnable {\r\n    address public feeRateImpl;\r\n\r\n    function setFeeProxy(address _feeRateImpl) public onlyOwner {\r\n        feeRateImpl = _feeRateImpl;\r\n    }\r\n    \r\n    function getFeeRate(address trader) external view returns (uint256) {\r\n        if(feeRateImpl == address(0))\r\n            return 0;\r\n        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender,trader);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/InitializableOwnable.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title Ownable\r\n  *\r\n * @notice Ownership related functions\r\n */\r\ncontract InitializableOwnable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n    bool internal _INITIALIZED_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier notInitialized() {\r\n        require(!_INITIALIZED_, \"_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function initOwner(address newOwner) public notInitialized {\r\n        _INITIALIZED_ = true;\r\n        _OWNER_ = newOwner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/PMMPricing.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {SafeMath} from \"../libraries/SafeMath.sol\";\r\nimport {DecimalMath} from \"../libraries/DecimalMath.sol\";\r\nimport {WorldesMath} from \"../libraries/WorldesMath.sol\";\r\n\r\n/**\r\n * @title Pricing\r\n  *\r\n * @notice Worldes Pricing model\r\n */\r\n\r\nlibrary PMMPricing {\r\n    using SafeMath for uint256;\r\n\r\n    enum RState {ONE, ABOVE_ONE, BELOW_ONE}\r\n\r\n    struct PMMState {\r\n        uint256 i;\r\n        uint256 K;\r\n        uint256 B;\r\n        uint256 Q;\r\n        uint256 B0;\r\n        uint256 Q0;\r\n        RState R;\r\n    }\r\n\r\n    // ============ buy & sell ============\r\n\r\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (uint256 receiveQuoteAmount, RState newR)\r\n    {\r\n        if (state.R == RState.ONE) {\r\n            // case 1: R=1\r\n            // R falls below one\r\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\r\n            newR = RState.BELOW_ONE;\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            uint256 backToOnePayBase = state.B0.sub(state.B);\r\n            uint256 backToOneReceiveQuote = state.Q.sub(state.Q0);\r\n            // case 2: R>1\r\n            // complex case, R status depends on trading amount\r\n            if (payBaseAmount < backToOnePayBase) {\r\n                // case 2.1: R status do not change\r\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\r\n                newR = RState.ABOVE_ONE;\r\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\r\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\r\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\r\n                    receiveQuoteAmount = backToOneReceiveQuote;\r\n                }\r\n            } else if (payBaseAmount == backToOnePayBase) {\r\n                // case 2.2: R status changes to ONE\r\n                receiveQuoteAmount = backToOneReceiveQuote;\r\n                newR = RState.ONE;\r\n            } else {\r\n                // case 2.3: R status changes to BELOW_ONE\r\n                receiveQuoteAmount = backToOneReceiveQuote.add(\r\n                    _ROneSellBaseToken(state, payBaseAmount.sub(backToOnePayBase))\r\n                );\r\n                newR = RState.BELOW_ONE;\r\n            }\r\n        } else {\r\n            // state.R == RState.BELOW_ONE\r\n            // case 3: R<1\r\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\r\n            newR = RState.BELOW_ONE;\r\n        }\r\n    }\r\n\r\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (uint256 receiveBaseAmount, RState newR)\r\n    {\r\n        if (state.R == RState.ONE) {\r\n            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\r\n            newR = RState.ABOVE_ONE;\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\r\n            newR = RState.ABOVE_ONE;\r\n        } else {\r\n            uint256 backToOnePayQuote = state.Q0.sub(state.Q);\r\n            uint256 backToOneReceiveBase = state.B.sub(state.B0);\r\n            if (payQuoteAmount < backToOnePayQuote) {\r\n                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\r\n                newR = RState.BELOW_ONE;\r\n                if (receiveBaseAmount > backToOneReceiveBase) {\r\n                    receiveBaseAmount = backToOneReceiveBase;\r\n                }\r\n            } else if (payQuoteAmount == backToOnePayQuote) {\r\n                receiveBaseAmount = backToOneReceiveBase;\r\n                newR = RState.ONE;\r\n            } else {\r\n                receiveBaseAmount = backToOneReceiveBase.add(\r\n                    _ROneSellQuoteToken(state, payQuoteAmount.sub(backToOnePayQuote))\r\n                );\r\n                newR = RState.ABOVE_ONE;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============ R = 1 cases ============\r\n\r\n    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        // in theory Q2 <= targetQuoteTokenAmount\r\n        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\r\n        return\r\n            WorldesMath._SolveQuadraticFunctionForTrade(\r\n                state.Q0,\r\n                state.Q0,\r\n                payBaseAmount,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            WorldesMath._SolveQuadraticFunctionForTrade(\r\n                state.B0,\r\n                state.B0,\r\n                payQuoteAmount,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ R < 1 cases ============\r\n\r\n    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            WorldesMath._GeneralIntegrate(\r\n                state.Q0,\r\n                state.Q.add(payQuoteAmount),\r\n                state.Q,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        return\r\n            WorldesMath._SolveQuadraticFunctionForTrade(\r\n                state.Q0,\r\n                state.Q,\r\n                payBaseAmount,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ R > 1 cases ============\r\n\r\n    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveQuoteToken\r\n        )\r\n    {\r\n        return\r\n            WorldesMath._GeneralIntegrate(\r\n                state.B0,\r\n                state.B.add(payBaseAmount),\r\n                state.B,\r\n                state.i,\r\n                state.K\r\n            );\r\n    }\r\n\r\n    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 // receiveBaseToken\r\n        )\r\n    {\r\n        return\r\n            WorldesMath._SolveQuadraticFunctionForTrade(\r\n                state.B0,\r\n                state.B,\r\n                payQuoteAmount,\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n    }\r\n\r\n    // ============ Helper functions ============\r\n\r\n    function adjustedTarget(PMMState memory state) internal pure {\r\n        if (state.R == RState.BELOW_ONE) {\r\n            state.Q0 = WorldesMath._SolveQuadraticFunctionForTarget(\r\n                state.Q,\r\n                state.B.sub(state.B0),\r\n                state.i,\r\n                state.K\r\n            );\r\n        } else if (state.R == RState.ABOVE_ONE) {\r\n            state.B0 = WorldesMath._SolveQuadraticFunctionForTarget(\r\n                state.B,\r\n                state.Q.sub(state.Q0),\r\n                DecimalMath.reciprocalFloor(state.i),\r\n                state.K\r\n            );\r\n        }\r\n    }\r\n\r\n    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\r\n        if (state.R == RState.BELOW_ONE) {\r\n            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\r\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\r\n            return DecimalMath.divFloor(state.i, R);\r\n        } else {\r\n            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\r\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\r\n            return DecimalMath.mulFloor(state.i, R);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title ReentrancyGuard\r\n  *\r\n * @notice Protect functions from Reentrancy Attack\r\n */\r\ncontract ReentrancyGuard {\r\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\r\n    // zero-state of _ENTERED_ is false\r\n    bool private _ENTERED_;\r\n\r\n    modifier preventReentrant() {\r\n        require(!_ENTERED_, \"REENTRANT\");\r\n        _ENTERED_ = true;\r\n        _;\r\n        _ENTERED_ = false;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n    This is a simplified version of OpenZepplin's SafeERC20 library\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IERC20} from \"../interfaces/IERC20.sol\";\r\nimport {SafeMath} from \"./SafeMath.sol\";\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/UniversalERC20.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\n\r\nimport {IERC20} from \"../interfaces/IERC20.sol\";\r\nimport {SafeERC20} from \"./SafeERC20.sol\";\r\nimport {SafeMath} from \"./SafeMath.sol\";\r\n\r\nlibrary UniversalERC20 {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 private constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n    function universalTransfer(\r\n        IERC20 token,\r\n        address payable to,\r\n        uint256 amount\r\n    ) internal {\r\n        if (amount > 0) {\r\n            if (isETH(token)) {\r\n                to.transfer(amount);\r\n            } else {\r\n                token.safeTransfer(to, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function universalApproveMax(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        uint256 allowance = token.allowance(address(this), to);\r\n        if (allowance < amount) {\r\n            if (allowance > 0) {\r\n                token.safeApprove(to, 0);\r\n            }\r\n            token.safeApprove(to, uint256(-1));\r\n        }\r\n    }\r\n\r\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\r\n        if (isETH(token)) {\r\n            return who.balance;\r\n        } else {\r\n            return token.balanceOf(who);\r\n        }\r\n    }\r\n\r\n    function tokenBalanceOf(IERC20 token, address who) internal view returns (uint256) {\r\n        return token.balanceOf(who);\r\n    }\r\n\r\n    function isETH(IERC20 token) internal pure returns (bool) {\r\n        return token == ETH_ADDRESS;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/WorldesMath.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {SafeMath} from \"./SafeMath.sol\";\r\nimport {DecimalMath} from \"./DecimalMath.sol\";\r\n\r\n/**\r\n * @title WorldesMath\r\n  *\r\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\r\n */\r\nlibrary WorldesMath {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n        Integrate worldes curve from V1 to V2\r\n        require V0>=V1>=V2>0\r\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\r\n        let V1-V2=delta\r\n        res = i*delta*(1-k+k(V0^2/V1/V2))\r\n\r\n        i is the price of V-res trading pair\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _GeneralIntegrate(\r\n        uint256 V0,\r\n        uint256 V1,\r\n        uint256 V2,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        require(V0 > 0, \"TARGET_IS_ZERO\");\r\n        uint256 fairAmount = i.mul(V1.sub(V2)); // i*delta\r\n        if (k == 0) {\r\n            return fairAmount.div(DecimalMath.ONE);\r\n        }\r\n        uint256 V0V0V1V2 = DecimalMath.divFloor(V0.mul(V0).div(V1), V2);\r\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\r\n        return DecimalMath.ONE.sub(k).add(penalty).mul(fairAmount).div(DecimalMath.ONE2);\r\n    }\r\n\r\n    /*\r\n        Follow the integration function above\r\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\r\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\r\n\r\n        i is the price of delta-V trading pair\r\n        give out target of V\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _SolveQuadraticFunctionForTarget(\r\n        uint256 V1,\r\n        uint256 delta,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        if (k == 0) {\r\n            return V1.add(DecimalMath.mulFloor(i, delta));\r\n        }\r\n        // V0 = V1*(1+(sqrt-1)/2k)\r\n        // sqrt = âˆš(1+4kidelta/V1)\r\n        // premium = 1+(sqrt-1)/2k\r\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\r\n\r\n        if (V1 == 0) {\r\n            return 0;\r\n        }\r\n        uint256 sqrt;\r\n        uint256 ki = (4 * k).mul(i);\r\n        if (ki == 0) {\r\n            sqrt = DecimalMath.ONE;\r\n        } else if ((ki * delta) / ki == delta) {\r\n            sqrt = (ki * delta).div(V1).add(DecimalMath.ONE2).sqrt();\r\n        } else {\r\n            sqrt = ki.div(V1).mul(delta).add(DecimalMath.ONE2).sqrt();\r\n        }\r\n        uint256 premium =\r\n            DecimalMath.divFloor(sqrt.sub(DecimalMath.ONE), k * 2).add(DecimalMath.ONE);\r\n        // V0 is greater than or equal to V1 according to the solution\r\n        return DecimalMath.mulFloor(V1, premium);\r\n    }\r\n\r\n    /*\r\n        Follow the integration expression above, we have:\r\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\r\n        Given Q1 and deltaB, solve Q2\r\n        This is a quadratic function and the standard version is\r\n        aQ2^2 + bQ2 + c = 0, where\r\n        a=1-k\r\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\r\n        c=-kQ0^2 \r\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\r\n        note: another root is negative, abondan\r\n\r\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\r\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\r\n        return |Q1-Q2|\r\n\r\n        as we only support sell amount as delta, the deltaB is always negative\r\n        the input ideltaB is actually -ideltaB in the equation\r\n\r\n        i is the price of delta-V trading pair\r\n\r\n        support k=1 & k=0 case\r\n\r\n        [round down]\r\n    */\r\n    function _SolveQuadraticFunctionForTrade(\r\n        uint256 V0,\r\n        uint256 V1,\r\n        uint256 delta,\r\n        uint256 i,\r\n        uint256 k\r\n    ) internal pure returns (uint256) {\r\n        require(V0 > 0, \"TARGET_IS_ZERO\");\r\n        if (delta == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (k == 0) {\r\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\r\n        }\r\n\r\n        if (k == DecimalMath.ONE) {\r\n            // if k==1\r\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\r\n            // temp = ideltaBQ1/Q0/Q0\r\n            // Q2 = Q1/(1+temp)\r\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\r\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\r\n            uint256 temp;\r\n            uint256 idelta = i.mul(delta);\r\n            if (idelta == 0) {\r\n                temp = 0;\r\n            } else if ((idelta * V1) / idelta == V1) {\r\n                temp = (idelta * V1).div(V0.mul(V0));\r\n            } else {\r\n                temp = delta.mul(V1).div(V0).mul(i).div(V0);\r\n            }\r\n            return V1.mul(temp).div(temp.add(DecimalMath.ONE));\r\n        }\r\n\r\n        // calculate -b value and sig\r\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\r\n        // part1 = (1-k)Q1 >=0\r\n        // part2 = kQ0^2/Q1-i*deltaB >=0\r\n        // bAbs = abs(part1-part2)\r\n        // if part1>part2 => b is negative => bSig is false\r\n        // if part2>part1 => b is positive => bSig is true\r\n        uint256 part2 = k.mul(V0).div(V1).mul(V0).add(i.mul(delta)); // kQ0^2/Q1-i*deltaB\r\n        uint256 bAbs = DecimalMath.ONE.sub(k).mul(V1); // (1-k)Q1\r\n\r\n        bool bSig;\r\n        if (bAbs >= part2) {\r\n            bAbs = bAbs - part2;\r\n            bSig = false;\r\n        } else {\r\n            bAbs = part2 - bAbs;\r\n            bSig = true;\r\n        }\r\n        bAbs = bAbs.div(DecimalMath.ONE);\r\n\r\n        // calculate sqrt\r\n        uint256 squareRoot =\r\n            DecimalMath.mulFloor(\r\n                DecimalMath.ONE.sub(k).mul(4),\r\n                DecimalMath.mulFloor(k, V0).mul(V0)\r\n            ); // 4(1-k)kQ0^2\r\n        squareRoot = bAbs.mul(bAbs).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\r\n\r\n        // final res\r\n        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\r\n        uint256 numerator;\r\n        if (bSig) {\r\n            numerator = squareRoot.sub(bAbs);\r\n            if (numerator == 0) {\r\n                revert(\"WorldesMath: should not be zero\");\r\n            }\r\n        } else {\r\n            numerator = bAbs.add(squareRoot);\r\n        }\r\n\r\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\r\n        if (V2 > V1) {\r\n            return 0;\r\n        } else {\r\n            return V1 - V2;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/proxy/WorldesApprove.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\n\r\nimport {IERC20} from \"../interfaces/IERC20.sol\";\r\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\r\nimport {InitializableOwnable} from \"../libraries/InitializableOwnable.sol\";\r\n\r\n\r\n/**\r\n * @title WorldesApprove\r\n  *\r\n * @notice Handle authorizations in Worldes platform\r\n */\r\ncontract WorldesApprove is InitializableOwnable {\r\n    using SafeERC20 for IERC20;\r\n    \r\n    // ============ Storage ============\r\n    uint256 private constant _TIMELOCK_DURATION_ = 3 days;\r\n    uint256 private constant _TIMELOCK_EMERGENCY_DURATION_ = 24 hours;\r\n    uint256 public _TIMELOCK_;\r\n    address public _PENDING_WORLDES_PROXY_;\r\n    address public _WORLDES_PROXY_;\r\n\r\n    // ============ Events ============\r\n\r\n    event SetWorldesProxy(address indexed oldProxy, address indexed newProxy);\r\n\r\n    \r\n    // ============ Modifiers ============\r\n    modifier notLocked() {\r\n        require(\r\n            _TIMELOCK_ <= block.timestamp,\r\n            \"SetProxy is timelocked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function init(address owner, address initProxyAddress) external {\r\n        initOwner(owner);\r\n        _WORLDES_PROXY_ = initProxyAddress;\r\n    }\r\n\r\n    function unlockSetProxy(address newSwapProxy) public onlyOwner {\r\n        if(_WORLDES_PROXY_ == address(0))\r\n            _TIMELOCK_ = block.timestamp + _TIMELOCK_EMERGENCY_DURATION_;\r\n        else\r\n            _TIMELOCK_ = block.timestamp + _TIMELOCK_DURATION_;\r\n        _PENDING_WORLDES_PROXY_ = newSwapProxy;\r\n    }\r\n\r\n\r\n    function lockSetProxy() public onlyOwner {\r\n       _PENDING_WORLDES_PROXY_ = address(0);\r\n       _TIMELOCK_ = 0;\r\n    }\r\n\r\n\r\n    function setWorldesProxy() external onlyOwner notLocked() {\r\n        emit SetWorldesProxy(_WORLDES_PROXY_, _PENDING_WORLDES_PROXY_);\r\n        _WORLDES_PROXY_ = _PENDING_WORLDES_PROXY_;\r\n        lockSetProxy();\r\n    }\r\n\r\n\r\n    function claimTokens(\r\n        address token,\r\n        address who,\r\n        address dest,\r\n        uint256 amount\r\n    ) external {\r\n        require(msg.sender == _WORLDES_PROXY_, \"WorldesApprove:Access restricted\");\r\n        if (amount > 0) {\r\n            IERC20(token).safeTransferFrom(who, dest, amount);\r\n        }\r\n    }\r\n\r\n    function getWorldesProxy() public view returns (address) {\r\n        return _WORLDES_PROXY_;\r\n    }\r\n}\r\n"
    },
    "contracts/proxy/WorldesApproveProxy.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IWorldesApprove} from \"../interfaces/IWorldesApprove.sol\";\r\nimport {InitializableOwnable} from \"../libraries/InitializableOwnable.sol\";\r\n\r\ninterface IWorldesApproveProxy {\r\n    function isAllowedProxy(address _proxy) external view returns (bool);\r\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @title WorldesApproveProxy\r\n  *\r\n * @notice Allow different version worldesproxy to claim from WorldesApprove\r\n */\r\ncontract WorldesApproveProxy is InitializableOwnable {\r\n    \r\n    // ============ Storage ============\r\n    uint256 private constant _TIMELOCK_DURATION_ = 3 days;\r\n    mapping (address => bool) public _IS_ALLOWED_PROXY_;\r\n    uint256 public _TIMELOCK_;\r\n    address public _PENDING_ADD_WORLDES_PROXY_;\r\n    address public immutable _WORLDES_APPROVE_;\r\n\r\n    // ============ Modifiers ============\r\n    modifier notLocked() {\r\n        require(\r\n            _TIMELOCK_ <= block.timestamp,\r\n            \"SetProxy is timelocked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address worldesApprove) public {\r\n        _WORLDES_APPROVE_ = worldesApprove;\r\n    }\r\n\r\n    function init(address owner, address[] memory proxies) external {\r\n        initOwner(owner);\r\n        for(uint i = 0; i < proxies.length; i++) \r\n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\r\n    }\r\n\r\n    function unlockAddProxy(address newSwapProxy) public onlyOwner {\r\n        _TIMELOCK_ = block.timestamp + _TIMELOCK_DURATION_;\r\n        _PENDING_ADD_WORLDES_PROXY_ = newSwapProxy;\r\n    }\r\n\r\n    function lockAddProxy() public onlyOwner {\r\n       _PENDING_ADD_WORLDES_PROXY_ = address(0);\r\n       _TIMELOCK_ = 0;\r\n    }\r\n\r\n\r\n    function addWorldesProxy() external onlyOwner notLocked() {\r\n        _IS_ALLOWED_PROXY_[_PENDING_ADD_WORLDES_PROXY_] = true;\r\n        lockAddProxy();\r\n    }\r\n\r\n    function removeWorldesProxy (address oldSwapProxy) public onlyOwner {\r\n        _IS_ALLOWED_PROXY_[oldSwapProxy] = false;\r\n    }\r\n    \r\n    function claimTokens(\r\n        address token,\r\n        address who,\r\n        address dest,\r\n        uint256 amount\r\n    ) external {\r\n        require(_IS_ALLOWED_PROXY_[msg.sender], \"WorldesApproveProxy:Access restricted\");\r\n        IWorldesApprove(_WORLDES_APPROVE_).claimTokens(\r\n            token,\r\n            who,\r\n            dest,\r\n            amount\r\n        );\r\n    }\r\n\r\n    function isAllowedProxy(address _proxy) external view returns (bool) {\r\n        return _IS_ALLOWED_PROXY_[_proxy];\r\n    }\r\n}\r\n"
    },
    "contracts/proxy/WorldesDspProxy.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\n\r\nimport {IWorldesApproveProxy} from \"./WorldesApproveProxy.sol\";\r\nimport {IERC20} from \"../interfaces/IERC20.sol\";\r\nimport {IWETH} from \"../interfaces/IWETH.sol\";\r\nimport {SafeMath} from \"../libraries/SafeMath.sol\";\r\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\r\nimport {DecimalMath} from \"../libraries/DecimalMath.sol\";\r\nimport {ReentrancyGuard} from \"../libraries/ReentrancyGuard.sol\";\r\nimport {IDSP} from \"../stablePool/interfaces/IDSP.sol\";\r\nimport {IDSPFactory} from \"../factory/DSPFactory.sol\";\r\n\r\n/**\r\n * @title WorldesDspProxy\r\n *\r\n * @notice Entrance of Worldes Stable Pair in Worldes platform\r\n */\r\ncontract WorldesDspProxy is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Storage ============\r\n\r\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public immutable _WETH_;\r\n    address public immutable _WORLDES_APPROVE_PROXY_;\r\n    address public immutable _DSP_FACTORY_;\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier judgeExpired(uint256 deadLine) {\r\n        require(deadLine >= block.timestamp, \"WorldesDspProxy: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    receive() external payable {}\r\n\r\n    constructor(\r\n        address dspFactory,\r\n        address payable weth,\r\n        address worldesApproveProxy\r\n    ) public {\r\n        _DSP_FACTORY_ = dspFactory;\r\n        _WETH_ = weth;\r\n        _WORLDES_APPROVE_PROXY_ = worldesApproveProxy;\r\n    }\r\n\r\n    // ============ DSP Functions (create & add liquidity) ============\r\n\r\n    function createStablePair(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        payable\r\n        preventReentrant\r\n        judgeExpired(deadLine)\r\n        returns (address newStablePair, uint256 shares)\r\n    {\r\n        {\r\n            address _baseToken = baseToken == _ETH_ADDRESS_ ? _WETH_ : baseToken;\r\n            address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\r\n            newStablePair = IDSPFactory(_DSP_FACTORY_).createStablePool(\r\n                _baseToken,\r\n                _quoteToken,\r\n                lpFeeRate,\r\n                i,\r\n                k,\r\n                isOpenTWAP\r\n            );\r\n        }\r\n\r\n        {\r\n            address _baseToken = baseToken;\r\n            address _quoteToken = quoteToken;\r\n            _deposit(\r\n                msg.sender,\r\n                newStablePair,\r\n                _baseToken,\r\n                baseInAmount,\r\n                _baseToken == _ETH_ADDRESS_\r\n            );\r\n            _deposit(\r\n                msg.sender,\r\n                newStablePair,\r\n                _quoteToken,\r\n                quoteInAmount,\r\n                _quoteToken == _ETH_ADDRESS_\r\n            );\r\n        }\r\n\r\n        (shares, , ) = IDSP(newStablePair).buyShares(msg.sender);\r\n    }\r\n\r\n    function addDSPLiquidity(\r\n        address dspAddress,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        payable\r\n        preventReentrant\r\n        judgeExpired(deadLine)\r\n        returns (\r\n            uint256 shares,\r\n            uint256 baseAdjustedInAmount,\r\n            uint256 quoteAdjustedInAmount\r\n        )\r\n    {\r\n        address _dsp = dspAddress;\r\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _addDSPLiquidity(\r\n            _dsp,\r\n            baseInAmount,\r\n            quoteInAmount\r\n        );\r\n        require(\r\n            baseAdjustedInAmount >= baseMinAmount && quoteAdjustedInAmount >= quoteMinAmount,\r\n            \"WorldesDspProxy: deposit amount is not enough\"\r\n        );\r\n\r\n        _deposit(msg.sender, _dsp, IDSP(_dsp)._BASE_TOKEN_(), baseAdjustedInAmount, flag == 1);\r\n        _deposit(msg.sender, _dsp, IDSP(_dsp)._QUOTE_TOKEN_(), quoteAdjustedInAmount, flag == 2);\r\n        \r\n        (shares, , ) = IDSP(_dsp).buyShares(msg.sender);\r\n\r\n        // refund dust eth\r\n        if (flag == 1 && msg.value > baseAdjustedInAmount) msg.sender.transfer(msg.value - baseAdjustedInAmount);\r\n        if (flag == 2 && msg.value > quoteAdjustedInAmount) msg.sender.transfer(msg.value - quoteAdjustedInAmount);\r\n    }\r\n\r\n\r\n    // =================== internal functions =====================\r\n\r\n    function _addDSPLiquidity(\r\n        address dspAddress,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount\r\n    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\r\n        (uint256 baseReserve, uint256 quoteReserve) = IDSP(dspAddress).getVaultReserve();\r\n        if (quoteReserve == 0 && baseReserve == 0) {\r\n            uint256 i = IDSP(dspAddress)._I_();\r\n            uint256 shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i)\r\n                ? DecimalMath.divFloor(quoteInAmount, i)\r\n                : baseInAmount;\r\n            baseAdjustedInAmount = shares;\r\n            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\r\n        }\r\n        if (quoteReserve > 0 && baseReserve > 0) {\r\n            uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\r\n            uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\r\n            if (baseIncreaseRatio <= quoteIncreaseRatio) {\r\n                baseAdjustedInAmount = baseInAmount;\r\n                quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\r\n            } else {\r\n                quoteAdjustedInAmount = quoteInAmount;\r\n                baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _deposit(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint256 amount,\r\n        bool isETH\r\n    ) internal {\r\n        if (isETH) {\r\n            if (amount > 0) {\r\n                IWETH(_WETH_).deposit{value: amount}();\r\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\r\n            }\r\n        } else {\r\n            IWorldesApproveProxy(_WORLDES_APPROVE_PROXY_).claimTokens(token, from, to, amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/proxy/WorldesDvmProxy.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\n\r\nimport {IWorldesDvmProxy} from \"../interfaces/IWorldesDvmProxy.sol\";\r\nimport {IWorldes} from \"../interfaces/IWorldes.sol\";\r\nimport {IWorldesApproveProxy} from \"./WorldesApproveProxy.sol\";\r\nimport {IERC20} from \"../interfaces/IERC20.sol\";\r\nimport {IWETH} from \"../interfaces/IWETH.sol\";\r\nimport {SafeMath} from \"../libraries/SafeMath.sol\";\r\nimport {UniversalERC20} from \"../libraries/UniversalERC20.sol\";\r\nimport {SafeERC20} from \"../libraries/SafeERC20.sol\";\r\nimport {DecimalMath} from \"../libraries/DecimalMath.sol\";\r\nimport {ReentrancyGuard} from \"../libraries/ReentrancyGuard.sol\";\r\nimport {InitializableOwnable} from \"../libraries/InitializableOwnable.sol\";\r\n\r\n/**\r\n * @title WorldesDvmProxy\r\n *\r\n * @notice Entrance of trading in Worldes platform\r\n */\r\ncontract WorldesDvmProxy is IWorldesDvmProxy, ReentrancyGuard, InitializableOwnable {\r\n    using SafeMath for uint256;\r\n    using UniversalERC20 for IERC20;\r\n\r\n    // ============ Storage ============\r\n\r\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n    address public immutable _WETH_;\r\n    address public immutable _WORLDES_APPROVE_PROXY_;\r\n    address public immutable _DVM_FACTORY_;\r\n    mapping (address => bool) public isWhiteListed;\r\n\r\n    // ============ Events ============\r\n\r\n    event OrderHistory(\r\n        address fromToken,\r\n        address toToken,\r\n        address sender,\r\n        uint256 fromAmount,\r\n        uint256 returnAmount\r\n    );\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier judgeExpired(uint256 deadLine) {\r\n        require(deadLine >= block.timestamp, \"WorldesDvmProxy: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    receive() external payable {}\r\n\r\n    constructor(\r\n        address dvmFactory,\r\n        address payable weth,\r\n        address worldesApproveProxy\r\n    ) public {\r\n        _DVM_FACTORY_ = dvmFactory;\r\n        _WETH_ = weth;\r\n        _WORLDES_APPROVE_PROXY_ = worldesApproveProxy;\r\n    }\r\n\r\n    function addWhiteList (address contractAddr) public onlyOwner {\r\n        isWhiteListed[contractAddr] = true;\r\n    }\r\n\r\n    function removeWhiteList (address contractAddr) public onlyOwner {\r\n        isWhiteListed[contractAddr] = false;\r\n    }\r\n\r\n    // ============ DVM Functions (create & add liquidity) ============\r\n\r\n    function createVendingMachine(\r\n        address baseToken,\r\n        address quoteToken,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 lpFeeRate,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        preventReentrant\r\n        judgeExpired(deadLine)\r\n        returns (address newVendingMachine, uint256 shares)\r\n    {\r\n        {\r\n            address _baseToken = baseToken == _ETH_ADDRESS_ ? _WETH_ : baseToken;\r\n            address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\r\n            newVendingMachine = IWorldes(_DVM_FACTORY_).createVendingMachine(\r\n                _baseToken,\r\n                _quoteToken,\r\n                lpFeeRate,\r\n                i,\r\n                k,\r\n                isOpenTWAP\r\n            );\r\n        }\r\n\r\n        {\r\n            address _baseToken = baseToken;\r\n            address _quoteToken = quoteToken;\r\n            _deposit(\r\n                msg.sender,\r\n                newVendingMachine,\r\n                _baseToken,\r\n                baseInAmount,\r\n                _baseToken == _ETH_ADDRESS_\r\n            );\r\n            _deposit(\r\n                msg.sender,\r\n                newVendingMachine,\r\n                _quoteToken,\r\n                quoteInAmount,\r\n                _quoteToken == _ETH_ADDRESS_\r\n            );\r\n        }\r\n\r\n        (shares, , ) = IWorldes(newVendingMachine).buyShares(msg.sender);\r\n    }\r\n\r\n    function addDVMLiquidity(\r\n        address dvmAddress,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        preventReentrant\r\n        judgeExpired(deadLine)\r\n        returns (\r\n            uint256 shares,\r\n            uint256 baseAdjustedInAmount,\r\n            uint256 quoteAdjustedInAmount\r\n        )\r\n    {\r\n        address _dvm = dvmAddress;\r\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _addDVMLiquidity(\r\n            _dvm,\r\n            baseInAmount,\r\n            quoteInAmount\r\n        );\r\n        require(\r\n            baseAdjustedInAmount >= baseMinAmount && quoteAdjustedInAmount >= quoteMinAmount,\r\n            \"WorldesDvmProxy: deposit amount is not enough\"\r\n        );\r\n\r\n        _deposit(msg.sender, _dvm, IWorldes(_dvm)._BASE_TOKEN_(), baseAdjustedInAmount, flag == 1);\r\n        _deposit(msg.sender, _dvm, IWorldes(_dvm)._QUOTE_TOKEN_(), quoteAdjustedInAmount, flag == 2);\r\n        \r\n        (shares, , ) = IWorldes(_dvm).buyShares(msg.sender);\r\n        // refund dust eth\r\n        if (flag == 1 && msg.value > baseAdjustedInAmount) msg.sender.transfer(msg.value - baseAdjustedInAmount);\r\n        if (flag == 2 && msg.value > quoteAdjustedInAmount) msg.sender.transfer(msg.value - quoteAdjustedInAmount);\r\n    }\r\n\r\n    function _addDVMLiquidity(\r\n        address dvmAddress,\r\n        uint256 baseInAmount,\r\n        uint256 quoteInAmount\r\n    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\r\n        (uint256 baseReserve, uint256 quoteReserve) = IWorldes(dvmAddress).getVaultReserve();\r\n        if (quoteReserve == 0 && baseReserve == 0) {\r\n            baseAdjustedInAmount = baseInAmount;\r\n            quoteAdjustedInAmount = quoteInAmount;\r\n        }\r\n        if (quoteReserve == 0 && baseReserve > 0) {\r\n            baseAdjustedInAmount = baseInAmount;\r\n            quoteAdjustedInAmount = 0;\r\n        }\r\n        if (quoteReserve > 0 && baseReserve > 0) {\r\n            uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\r\n            uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\r\n            if (baseIncreaseRatio <= quoteIncreaseRatio) {\r\n                baseAdjustedInAmount = baseInAmount;\r\n                quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\r\n            } else {\r\n                quoteAdjustedInAmount = quoteInAmount;\r\n                baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ============ Swap ============\r\n\r\n    function worldesSwapETHToToken(\r\n        address toToken,\r\n        uint256 minReturnAmount,\r\n        address[] memory worldesPairs,\r\n        uint256 directions,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(worldesPairs.length > 0, \"WorldesDvmProxy: PAIRS_EMPTY\");\r\n        require(minReturnAmount > 0, \"WorldesDvmProxy: RETURN_AMOUNT_ZERO\");\r\n        \r\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\r\n        IWETH(_WETH_).deposit{value: msg.value}();\r\n        SafeERC20.safeTransfer(IERC20(_WETH_), worldesPairs[0], msg.value);\r\n\r\n        for (uint256 i = 0; i < worldesPairs.length; i++) {\r\n            if (i == worldesPairs.length - 1) {\r\n                if (directions & 1 == 0) {\r\n                    IWorldes(worldesPairs[i]).sellBase(msg.sender);\r\n                } else {\r\n                    IWorldes(worldesPairs[i]).sellQuote(msg.sender);\r\n                }\r\n            } else {\r\n                if (directions & 1 == 0) {\r\n                    IWorldes(worldesPairs[i]).sellBase(worldesPairs[i + 1]);\r\n                } else {\r\n                    IWorldes(worldesPairs[i]).sellQuote(worldesPairs[i + 1]);\r\n                }\r\n            }\r\n            directions = directions >> 1;\r\n        }\r\n\r\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\r\n        require(returnAmount >= minReturnAmount, \"WorldesDvmProxy: Return amount is not enough\");\r\n\r\n        emit OrderHistory(\r\n            _ETH_ADDRESS_,\r\n            toToken,\r\n            msg.sender,\r\n            msg.value,\r\n            returnAmount\r\n        );\r\n    }\r\n\r\n    function worldesSwapTokenToETH(\r\n        address fromToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory worldesPairs,\r\n        uint256 directions,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(worldesPairs.length > 0, \"WorldesDvmProxy: PAIRS_EMPTY\");\r\n        require(minReturnAmount > 0, \"WorldesDvmProxy: RETURN_AMOUNT_ZERO\");\r\n        \r\n        IWorldesApproveProxy(_WORLDES_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, worldesPairs[0], fromTokenAmount);\r\n\r\n        for (uint256 i = 0; i < worldesPairs.length; i++) {\r\n            if (i == worldesPairs.length - 1) {\r\n                if (directions & 1 == 0) {\r\n                    IWorldes(worldesPairs[i]).sellBase(address(this));\r\n                } else {\r\n                    IWorldes(worldesPairs[i]).sellQuote(address(this));\r\n                }\r\n            } else {\r\n                if (directions & 1 == 0) {\r\n                    IWorldes(worldesPairs[i]).sellBase(worldesPairs[i + 1]);\r\n                } else {\r\n                    IWorldes(worldesPairs[i]).sellQuote(worldesPairs[i + 1]);\r\n                }\r\n            }\r\n            directions = directions >> 1;\r\n        }\r\n        returnAmount = IWETH(_WETH_).balanceOf(address(this));\r\n        require(returnAmount >= minReturnAmount, \"WorldesDvmProxy: Return amount is not enough\");\r\n        IWETH(_WETH_).withdraw(returnAmount);\r\n        msg.sender.transfer(returnAmount);\r\n\r\n        emit OrderHistory(\r\n            fromToken,\r\n            _ETH_ADDRESS_,\r\n            msg.sender,\r\n            fromTokenAmount,\r\n            returnAmount\r\n        );\r\n    }\r\n\r\n    function worldesSwapTokenToToken(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        address[] memory worldesPairs,\r\n        uint256 directions,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(worldesPairs.length > 0, \"WorldesDvmProxy: PAIRS_EMPTY\");\r\n        require(minReturnAmount > 0, \"WorldesDvmProxy: RETURN_AMOUNT_ZERO\");\r\n\r\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\r\n        IWorldesApproveProxy(_WORLDES_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, worldesPairs[0], fromTokenAmount);\r\n\r\n        for (uint256 i = 0; i < worldesPairs.length; i++) {\r\n            if (i == worldesPairs.length - 1) {\r\n                if (directions & 1 == 0) {\r\n                    IWorldes(worldesPairs[i]).sellBase(msg.sender);\r\n                } else {\r\n                    IWorldes(worldesPairs[i]).sellQuote(msg.sender);\r\n                }\r\n            } else {\r\n                if (directions& 1 == 0) {\r\n                    IWorldes(worldesPairs[i]).sellBase(worldesPairs[i + 1]);\r\n                } else {\r\n                    IWorldes(worldesPairs[i]).sellQuote(worldesPairs[i + 1]);\r\n                }\r\n            }\r\n            directions = directions >> 1;\r\n        }\r\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\r\n        require(returnAmount >= minReturnAmount, \"WorldesDvmProxy: Return amount is not enough\");\r\n\r\n        emit OrderHistory(\r\n            fromToken,\r\n            toToken,\r\n            msg.sender,\r\n            fromTokenAmount,\r\n            returnAmount\r\n        );\r\n    }\r\n\r\n    function externalSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        address approveTarget,\r\n        address swapTarget,\r\n        uint256 fromTokenAmount,\r\n        uint256 minReturnAmount,\r\n        bytes memory callDataConcat,\r\n        uint256 deadLine\r\n    )\r\n        external\r\n        override\r\n        payable\r\n        judgeExpired(deadLine)\r\n        returns (uint256 returnAmount)\r\n    {\r\n        require(minReturnAmount > 0, \"WorldesDvmProxy: RETURN_AMOUNT_ZERO\");\r\n        \r\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\r\n        if (fromToken != _ETH_ADDRESS_) {\r\n            IWorldesApproveProxy(_WORLDES_APPROVE_PROXY_).claimTokens(\r\n                fromToken,\r\n                msg.sender,\r\n                address(this),\r\n                fromTokenAmount\r\n            );\r\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\r\n        }\r\n\r\n        require(isWhiteListed[swapTarget], \"WorldesDvmProxy: Not Whitelist Contract\");\r\n        (bool success, ) = swapTarget.call{value: fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\r\n\r\n        require(success, \"WorldesDvmProxy: External Swap execution Failed\");\r\n\r\n        IERC20(toToken).universalTransfer(\r\n            msg.sender,\r\n            IERC20(toToken).universalBalanceOf(address(this))\r\n        );\r\n\r\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\r\n        require(returnAmount >= minReturnAmount, \"WorldesDvmProxy: Return amount is not enough\");\r\n\r\n        emit OrderHistory(\r\n            fromToken,\r\n            toToken,\r\n            msg.sender,\r\n            fromTokenAmount,\r\n            returnAmount\r\n        );\r\n    }\r\n    \r\n\r\n    function _deposit(\r\n        address from,\r\n        address to,\r\n        address token,\r\n        uint256 amount,\r\n        bool isETH\r\n    ) internal {\r\n        if (isETH) {\r\n            if (amount > 0) {\r\n                require(msg.value == amount, \"ETH_VALUE_WRONG\");\r\n                IWETH(_WETH_).deposit{value: amount}();\r\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\r\n            }\r\n        } else {\r\n            IWorldesApproveProxy(_WORLDES_APPROVE_PROXY_).claimTokens(token, from, to, amount);\r\n        }\r\n    }\r\n\r\n    function _withdraw(\r\n        address payable to,\r\n        address token,\r\n        uint256 amount,\r\n        bool isETH\r\n    ) internal {\r\n        if (isETH) {\r\n            if (amount > 0) {\r\n                IWETH(_WETH_).withdraw(amount);\r\n                to.transfer(amount);\r\n            }\r\n        } else {\r\n            if (amount > 0) {\r\n                SafeERC20.safeTransfer(IERC20(token), to, amount);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/stablePool/implements/DSP.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IFeeRateModel} from \"../../libraries/FeeRateModel.sol\";\r\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\r\nimport {DSPTrader} from \"./DSPTrader.sol\";\r\nimport {DSPFunding} from \"./DSPFunding.sol\";\r\nimport {DSPVault} from \"./DSPVault.sol\";\r\n\r\n/**\r\n * @title StablePool\r\n  *\r\n * @notice StablePool initialization\r\n */\r\ncontract DSP is DSPTrader, DSPFunding {\r\n    function init(\r\n        address maintainer,\r\n        address baseTokenAddress,\r\n        address quoteTokenAddress,\r\n        uint256 lpFeeRate,\r\n        address mtFeeRateModel,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external {\r\n        require(!_DSP_INITIALIZED_, \"DSP_INITIALIZED\");\r\n        _DSP_INITIALIZED_ = true;\r\n        \r\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\r\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\r\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\r\n\r\n        require(i > 0 && i <= 10**36);\r\n        _I_ = i;\r\n\r\n        require(k <= 10**18);\r\n        _K_ = k;\r\n\r\n        _LP_FEE_RATE_ = lpFeeRate;\r\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\r\n        _MAINTAINER_ = maintainer;\r\n\r\n        _IS_OPEN_TWAP_ = isOpenTWAP;\r\n        if (isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\r\n\r\n        string memory connect = \"_\";\r\n        string memory suffix = \"DLP\";\r\n\r\n        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\r\n        symbol = \"DLP\";\r\n        decimals = _BASE_TOKEN_.decimals();\r\n\r\n        // ============================== Permit ====================================\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\"1\")),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        // ==========================================================================\r\n    }\r\n\r\n    function addressToShortString(address _addr) public pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(8);\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    // ============ Version Control ============\r\n\r\n    function version() external pure returns (string memory) {\r\n        return \"DSP 1.0.1\";\r\n    }\r\n}\r\n"
    },
    "contracts/stablePool/implements/DSPFunding.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {DSPVault} from \"./DSPVault.sol\";\r\nimport {DecimalMath} from \"../../libraries/DecimalMath.sol\";\r\nimport {IWorldesCallee} from \"../../interfaces/IWorldesCallee.sol\";\r\n\r\ncontract DSPFunding is DSPVault {\r\n    // ============ Events ============\r\n\r\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\r\n\r\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\r\n\r\n    // ============ Buy & Sell Shares ============\r\n\r\n    // buy shares [round down]\r\n    function buyShares(address to)\r\n        external\r\n        preventReentrant\r\n        returns (\r\n            uint256 shares,\r\n            uint256 baseInput,\r\n            uint256 quoteInput\r\n        )\r\n    {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 baseReserve = _BASE_RESERVE_;\r\n        uint256 quoteReserve = _QUOTE_RESERVE_;\r\n\r\n        baseInput = baseBalance.sub(baseReserve);\r\n        quoteInput = quoteBalance.sub(quoteReserve);\r\n        require(baseInput > 0, \"NO_BASE_INPUT\");\r\n\r\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\r\n        // But May Happenï¼Œreserve >0 But totalSupply = 0\r\n        if (totalSupply == 0) {\r\n            // case 1. initial supply\r\n            require(quoteBalance > 0, \"ZERO_QUOTE_AMOUNT\");\r\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)\r\n                ? DecimalMath.divFloor(quoteBalance, _I_)\r\n                : baseBalance;\r\n            _BASE_TARGET_ = uint112(shares);\r\n            _QUOTE_TARGET_ = uint112(DecimalMath.mulFloor(shares, _I_));\r\n            require(shares > 2001, \"MINT_AMOUNT_NOT_ENOUGH\");\r\n            _mint(address(0), 1001);\r\n            shares -= 1001;\r\n        } else if (baseReserve > 0 && quoteReserve > 0) {\r\n            // case 2. normal case\r\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\r\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\r\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\r\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\r\n\r\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).add(DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)));\r\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).add(DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)));\r\n        }\r\n        _mint(to, shares);\r\n        _setReserve(baseBalance, quoteBalance);\r\n        emit BuyShares(to, shares, _SHARES_[to]);\r\n    }\r\n\r\n    // sell shares [round down]\r\n    function sellShares(\r\n        uint256 shareAmount,\r\n        address to,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        bytes calldata data,\r\n        uint256 deadline\r\n    ) external preventReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\r\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\r\n        require(shareAmount <= _SHARES_[msg.sender], \"DLP_NOT_ENOUGH\");\r\n        require(to != address(this), \"SELL_BACK_NOT_ALLOWED\");\r\n\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 totalShares = totalSupply;\r\n\r\n        baseAmount = baseBalance.mul(shareAmount).div(totalShares);\r\n        quoteAmount = quoteBalance.mul(shareAmount).div(totalShares);\r\n\r\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).sub(uint256(_BASE_TARGET_).mul(shareAmount).divCeil(totalShares)));\r\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).sub(uint256(_QUOTE_TARGET_).mul(shareAmount).divCeil(totalShares)));\r\n\r\n        require(\r\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\r\n            \"WITHDRAW_NOT_ENOUGH\"\r\n        );\r\n\r\n        _burn(msg.sender, shareAmount);\r\n        _transferBaseOut(to, baseAmount);\r\n        _transferQuoteOut(to, quoteAmount);\r\n        _sync();\r\n\r\n        if (data.length > 0) {\r\n            //Same as DVM \r\n            IWorldesCallee(to).DVMSellShareCall(\r\n                msg.sender,\r\n                shareAmount,\r\n                baseAmount,\r\n                quoteAmount,\r\n                data\r\n            );\r\n        }\r\n\r\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\r\n    }\r\n}\r\n"
    },
    "contracts/stablePool/implements/DSPStorage.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {ReentrancyGuard} from \"../../libraries/ReentrancyGuard.sol\";\r\nimport {SafeMath} from \"../../libraries/SafeMath.sol\";\r\nimport {WorldesMath} from \"../../libraries/WorldesMath.sol\";\r\nimport {DecimalMath} from \"../../libraries/DecimalMath.sol\";\r\nimport {IFeeRateModel} from \"../../libraries/FeeRateModel.sol\";\r\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\r\nimport {PMMPricing} from \"../../libraries/PMMPricing.sol\";\r\n\r\ncontract DSPStorage is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    bool internal _DSP_INITIALIZED_;\r\n    bool public _IS_OPEN_TWAP_ = false;\r\n    \r\n    // ============ Core Address ============\r\n\r\n    address public _MAINTAINER_;\r\n\r\n    IERC20 public _BASE_TOKEN_;\r\n    IERC20 public _QUOTE_TOKEN_;\r\n\r\n    uint112 public _BASE_RESERVE_;\r\n    uint112 public _QUOTE_RESERVE_;\r\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\r\n    \r\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\r\n\r\n    uint112 public _BASE_TARGET_;\r\n    uint112 public _QUOTE_TARGET_;\r\n    uint32 public _RState_;\r\n\r\n    // ============ Shares (ERC20) ============\r\n\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    string public name;\r\n\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) internal _SHARES_;\r\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\r\n\r\n    // ================= Permit ======================\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    // ============ Variables for Pricing ============\r\n\r\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\r\n\r\n    uint256 public _LP_FEE_RATE_;\r\n    uint256 public _K_;\r\n    uint256 public _I_;\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\r\n        state.i = _I_;\r\n        state.K = _K_;\r\n        state.B = _BASE_RESERVE_;\r\n        state.Q = _QUOTE_RESERVE_;\r\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\r\n        state.Q0 = _QUOTE_TARGET_;\r\n        state.R = PMMPricing.RState(_RState_);\r\n        PMMPricing.adjustedTarget(state);\r\n    }\r\n\r\n    function getPMMStateForCall()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 i,\r\n            uint256 K,\r\n            uint256 B,\r\n            uint256 Q,\r\n            uint256 B0,\r\n            uint256 Q0,\r\n            uint256 R\r\n        )\r\n    {\r\n        PMMPricing.PMMState memory state = getPMMState();\r\n        i = state.i;\r\n        K = state.K;\r\n        B = state.B;\r\n        Q = state.Q;\r\n        B0 = state.B0;\r\n        Q0 = state.Q0;\r\n        R = uint256(state.R);\r\n    }\r\n\r\n    function getMidPrice() public view returns (uint256 midPrice) {\r\n        return PMMPricing.getMidPrice(getPMMState());\r\n    }\r\n}\r\n"
    },
    "contracts/stablePool/implements/DSPTrader.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {DSPVault} from \"./DSPVault.sol\";\r\nimport {SafeMath} from \"../../libraries/SafeMath.sol\";\r\nimport {DecimalMath} from \"../../libraries/DecimalMath.sol\";\r\nimport {PMMPricing} from \"../../libraries/PMMPricing.sol\";\r\nimport {IWorldesCallee} from \"../../interfaces/IWorldesCallee.sol\";\r\n\r\ncontract DSPTrader is DSPVault {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Events ============\r\n\r\n    event WorldesSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromAmount,\r\n        uint256 toAmount,\r\n        address trader,\r\n        address receiver\r\n    );\r\n\r\n    event WorldesFlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\r\n\r\n    event RChange(PMMPricing.RState newRState);\r\n\r\n    // ============ Trade Functions ============\r\n\r\n    function sellBase(address to) external preventReentrant returns (uint256 receiveQuoteAmount) {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\r\n        uint256 mtFee;\r\n        uint256 newBaseTarget;\r\n        PMMPricing.RState newRState;\r\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\r\n\r\n        _transferQuoteOut(to, receiveQuoteAmount);\r\n        _transferQuoteOut(_MAINTAINER_, mtFee);\r\n\r\n        // update TARGET\r\n        if (_RState_ != uint32(newRState)) {\r\n            require(newBaseTarget <= uint112(-1), \"OVERFLOW\");\r\n            _BASE_TARGET_ = uint112(newBaseTarget);\r\n            _RState_ = uint32(newRState);\r\n            emit RChange(newRState);\r\n        }\r\n\r\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\r\n\r\n        emit WorldesSwap(\r\n            address(_BASE_TOKEN_),\r\n            address(_QUOTE_TOKEN_),\r\n            baseInput,\r\n            receiveQuoteAmount,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    function sellQuote(address to) external preventReentrant returns (uint256 receiveBaseAmount) {\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\r\n        uint256 mtFee;\r\n        uint256 newQuoteTarget;\r\n        PMMPricing.RState newRState;\r\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(\r\n            tx.origin,\r\n            quoteInput\r\n        );\r\n\r\n        _transferBaseOut(to, receiveBaseAmount);\r\n        _transferBaseOut(_MAINTAINER_, mtFee);\r\n\r\n        // update TARGET\r\n        if (_RState_ != uint32(newRState)) {\r\n            require(newQuoteTarget <= uint112(-1), \"OVERFLOW\");\r\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\r\n            _RState_ = uint32(newRState);\r\n            emit RChange(newRState);\r\n        }\r\n\r\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\r\n\r\n        emit WorldesSwap(\r\n            address(_QUOTE_TOKEN_),\r\n            address(_BASE_TOKEN_),\r\n            quoteInput,\r\n            receiveBaseAmount,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    function flashLoan(\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        address assetTo,\r\n        bytes calldata data\r\n    ) external preventReentrant {\r\n        _transferBaseOut(assetTo, baseAmount);\r\n        _transferQuoteOut(assetTo, quoteAmount);\r\n\r\n        if (data.length > 0)\r\n            IWorldesCallee(assetTo).DSPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\r\n\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n\r\n        // no input -> pure loss\r\n        require(\r\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\r\n            \"FLASH_LOAN_FAILED\"\r\n        );\r\n\r\n        // sell quote case\r\n        // quote input + base output\r\n        if (baseBalance < _BASE_RESERVE_) {\r\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\r\n            (\r\n                uint256 receiveBaseAmount,\r\n                uint256 mtFee,\r\n                PMMPricing.RState newRState,\r\n                uint256 newQuoteTarget\r\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\r\n            require(\r\n                uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount,\r\n                \"FLASH_LOAN_FAILED\"\r\n            );\r\n\r\n            _transferBaseOut(_MAINTAINER_, mtFee);\r\n            if (_RState_ != uint32(newRState)) {\r\n                require(newQuoteTarget <= uint112(-1), \"OVERFLOW\");\r\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\r\n                _RState_ = uint32(newRState);\r\n                emit RChange(newRState);\r\n            }\r\n            emit WorldesSwap(\r\n                address(_QUOTE_TOKEN_),\r\n                address(_BASE_TOKEN_),\r\n                quoteInput,\r\n                receiveBaseAmount,\r\n                msg.sender,\r\n                assetTo\r\n            );\r\n        }\r\n\r\n        // sell base case\r\n        // base input + quote output\r\n        if (quoteBalance < _QUOTE_RESERVE_) {\r\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\r\n            (\r\n                uint256 receiveQuoteAmount,\r\n                uint256 mtFee,\r\n                PMMPricing.RState newRState,\r\n                uint256 newBaseTarget\r\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\r\n            require(\r\n                uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount,\r\n                \"FLASH_LOAN_FAILED\"\r\n            );\r\n\r\n            _transferQuoteOut(_MAINTAINER_, mtFee);\r\n            if (_RState_ != uint32(newRState)) {\r\n                require(newBaseTarget <= uint112(-1), \"OVERFLOW\");\r\n                _BASE_TARGET_ = uint112(newBaseTarget);\r\n                _RState_ = uint32(newRState);\r\n                emit RChange(newRState);\r\n            }\r\n            emit WorldesSwap(\r\n                address(_BASE_TOKEN_),\r\n                address(_QUOTE_TOKEN_),\r\n                baseInput,\r\n                receiveQuoteAmount,\r\n                msg.sender,\r\n                assetTo\r\n            );\r\n        }\r\n\r\n        _sync();\r\n\r\n        emit WorldesFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\r\n    }\r\n\r\n    // ============ Query Functions ============\r\n\r\n    function querySellBase(address trader, uint256 payBaseAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 receiveQuoteAmount,\r\n            uint256 mtFee,\r\n            PMMPricing.RState newRState,\r\n            uint256 newBaseTarget\r\n        )\r\n    {\r\n        PMMPricing.PMMState memory state = getPMMState();\r\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\r\n\r\n        uint256 lpFeeRate = _LP_FEE_RATE_;\r\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\r\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\r\n        receiveQuoteAmount = receiveQuoteAmount\r\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\r\n            .sub(mtFee);\r\n        newBaseTarget = state.B0;\r\n    }\r\n\r\n    function querySellQuote(address trader, uint256 payQuoteAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 receiveBaseAmount,\r\n            uint256 mtFee,\r\n            PMMPricing.RState newRState,\r\n            uint256 newQuoteTarget\r\n        )\r\n    {\r\n        PMMPricing.PMMState memory state = getPMMState();\r\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\r\n\r\n        uint256 lpFeeRate = _LP_FEE_RATE_;\r\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\r\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\r\n        receiveBaseAmount = receiveBaseAmount\r\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\r\n            .sub(mtFee);\r\n        newQuoteTarget = state.Q0;\r\n    }\r\n}\r\n"
    },
    "contracts/stablePool/implements/DSPVault.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\r\nimport {SafeMath} from \"../../libraries/SafeMath.sol\";\r\nimport {DecimalMath} from \"../../libraries/DecimalMath.sol\";\r\nimport {PMMPricing} from \"../../libraries/PMMPricing.sol\";\r\nimport {SafeERC20} from \"../../libraries/SafeERC20.sol\";\r\nimport {DSPStorage} from \"./DSPStorage.sol\";\r\n\r\ncontract DSPVault is DSPStorage {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ============ Events ============\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    event Mint(address indexed user, uint256 value);\r\n\r\n    event Burn(address indexed user, uint256 value);\r\n\r\n    // ============ View Functions ============\r\n\r\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\r\n        baseReserve = _BASE_RESERVE_;\r\n        quoteReserve = _QUOTE_RESERVE_;\r\n    }\r\n\r\n    function getUserFeeRate(address user)\r\n        external\r\n        view\r\n        returns (uint256 lpFeeRate, uint256 mtFeeRate)\r\n    {\r\n        lpFeeRate = _LP_FEE_RATE_;\r\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\r\n    }\r\n\r\n    // ============ Asset In ============\r\n\r\n    function getBaseInput() public view returns (uint256 input) {\r\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\r\n    }\r\n\r\n    function getQuoteInput() public view returns (uint256 input) {\r\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\r\n    }\r\n\r\n    // ============ TWAP UPDATE ===========\r\n\r\n    function _twapUpdate() internal {\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\r\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\r\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\r\n        }\r\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\r\n    }\r\n\r\n    // ============ Set States ============\r\n\r\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\r\n        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), \"OVERFLOW\");\r\n        _BASE_RESERVE_ = uint112(baseReserve);\r\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\r\n\r\n        if (_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n    function _sync() internal {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\r\n        if (baseBalance != _BASE_RESERVE_) {\r\n            _BASE_RESERVE_ = uint112(baseBalance);\r\n        }\r\n        if (quoteBalance != _QUOTE_RESERVE_) {\r\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\r\n        }\r\n\r\n        if (_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n    function sync() external preventReentrant {\r\n        _sync();\r\n    }\r\n\r\n    function correctRState() public {\r\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_<_BASE_TARGET_) {\r\n          _RState_ = uint32(PMMPricing.RState.ONE);\r\n          _BASE_TARGET_ = _BASE_RESERVE_;\r\n          _QUOTE_TARGET_ = _QUOTE_RESERVE_;\r\n        }\r\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_<_QUOTE_TARGET_) {\r\n          _RState_ = uint32(PMMPricing.RState.ONE);\r\n          _BASE_TARGET_ = _BASE_RESERVE_;\r\n          _QUOTE_TARGET_ = _QUOTE_RESERVE_;\r\n        }\r\n    }\r\n\r\n    // ============ Asset Out ============\r\n\r\n    function _transferBaseOut(address to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            _BASE_TOKEN_.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    function _transferQuoteOut(address to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    // ============ Shares (ERC20) ============\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param to The address to transfer to.\r\n     * @param amount The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        require(amount <= _SHARES_[msg.sender], \"BALANCE_NOT_ENOUGH\");\r\n\r\n        _SHARES_[msg.sender] = _SHARES_[msg.sender].sub(amount);\r\n        _SHARES_[to] = _SHARES_[to].add(amount);\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the the balance of.\r\n     * @return balance An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance) {\r\n        return _SHARES_[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param amount uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        require(amount <= _SHARES_[from], \"BALANCE_NOT_ENOUGH\");\r\n        require(amount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\r\n\r\n        _SHARES_[from] = _SHARES_[from].sub(amount);\r\n        _SHARES_[to] = _SHARES_[to].add(amount);\r\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(amount);\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @param spender The address which will spend the funds.\r\n     * @param amount The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        _ALLOWED_[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _ALLOWED_[owner][spender];\r\n    }\r\n\r\n    function _mint(address user, uint256 value) internal {\r\n        require(value > 1000, \"MINT_AMOUNT_NOT_ENOUGH\");\r\n        _SHARES_[user] = _SHARES_[user].add(value);\r\n        totalSupply = totalSupply.add(value);\r\n        emit Mint(user, value);\r\n        emit Transfer(address(0), user, value);\r\n    }\r\n\r\n    function _burn(address user, uint256 value) internal {\r\n        _SHARES_[user] = _SHARES_[user].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Burn(user, value);\r\n        emit Transfer(user, address(0), value);\r\n    }\r\n\r\n    // ============================ Permit ======================================\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"DSP_LP: EXPIRED\");\r\n        bytes32 digest =\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR,\r\n                    keccak256(\r\n                        abi.encode(\r\n                            PERMIT_TYPEHASH,\r\n                            owner,\r\n                            spender,\r\n                            value,\r\n                            nonces[owner]++,\r\n                            deadline\r\n                        )\r\n                    )\r\n                )\r\n            );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(\r\n            recoveredAddress != address(0) && recoveredAddress == owner,\r\n            \"DSP_LP: INVALID_SIGNATURE\"\r\n        );\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/stablePool/interfaces/IDSP.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IDSP {\r\n    function init(\r\n        address maintainer,\r\n        address baseTokenAddress,\r\n        address quoteTokenAddress,\r\n        uint256 lpFeeRate,\r\n        address mtFeeRateModel,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external;\r\n\r\n    function _BASE_TOKEN_() external view returns (address);\r\n\r\n    function _QUOTE_TOKEN_() external view returns (address);\r\n\r\n    function _I_() external view returns (uint256);\r\n\r\n    function _MT_FEE_RATE_MODEL_() external view returns (address);\r\n\r\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\r\n\r\n    function sellBase(address to) external returns (uint256);\r\n\r\n    function sellQuote(address to) external returns (uint256);\r\n\r\n    function buyShares(address to) external returns (uint256,uint256,uint256);\r\n}\r\n"
    },
    "contracts/vendingMachine/implements/DVM.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IFeeRateModel} from \"../../libraries/FeeRateModel.sol\";\r\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\r\nimport {DVMTrader} from \"./DVMTrader.sol\";\r\nimport {DVMFunding} from \"./DVMFunding.sol\";\r\nimport {DVMVault} from \"./DVMVault.sol\";\r\n\r\n/**\r\n * @title VendingMachine\r\n  *\r\n * @notice VendingMachine initialization\r\n */\r\ncontract DVM is DVMTrader, DVMFunding {\r\n    function init(\r\n        address maintainer,\r\n        address baseTokenAddress,\r\n        address quoteTokenAddress,\r\n        uint256 lpFeeRate,\r\n        address mtFeeRateModel,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external {\r\n        require(!_DVM_INITIALIZED_, \"DVM_INITIALIZED\");\r\n        _DVM_INITIALIZED_ = true;\r\n        \r\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\r\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\r\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\r\n\r\n        require(i > 0 && i <= 10**36);\r\n        _I_ = i;\r\n\r\n        require(k <= 10**18);\r\n        _K_ = k;\r\n\r\n        _LP_FEE_RATE_ = lpFeeRate;\r\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\r\n        _MAINTAINER_ = maintainer;\r\n\r\n        _IS_OPEN_TWAP_ = isOpenTWAP;\r\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\r\n\r\n        string memory connect = \"_\";\r\n        string memory suffix = \"DLP\";\r\n\r\n        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\r\n        symbol = \"DLP\";\r\n        decimals = _BASE_TOKEN_.decimals();\r\n\r\n        // ============================== Permit ====================================\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(\"1\")),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n        // ==========================================================================\r\n    }\r\n\r\n    function addressToShortString(address _addr) public pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(_addr));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(8);\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    // ============ Version Control ============\r\n    \r\n    function version() external pure returns (string memory) {\r\n        return \"DVM 1.0.2\";\r\n    }\r\n}\r\n"
    },
    "contracts/vendingMachine/implements/DVMFunding.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {DVMVault} from \"./DVMVault.sol\";\r\nimport {DecimalMath} from \"../../libraries/DecimalMath.sol\";\r\nimport {IWorldesCallee} from \"../../interfaces/IWorldesCallee.sol\";\r\n\r\ncontract DVMFunding is DVMVault {\r\n    // ============ Events ============\r\n\r\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\r\n\r\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\r\n\r\n    // ============ Buy & Sell Shares ============\r\n\r\n    // buy shares [round down]\r\n    function buyShares(address to)\r\n        external\r\n        preventReentrant\r\n        returns (\r\n            uint256 shares,\r\n            uint256 baseInput,\r\n            uint256 quoteInput\r\n        )\r\n    {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 baseReserve = _BASE_RESERVE_;\r\n        uint256 quoteReserve = _QUOTE_RESERVE_;\r\n\r\n        baseInput = baseBalance.sub(baseReserve);\r\n        quoteInput = quoteBalance.sub(quoteReserve);\r\n        require(baseInput > 0, \"NO_BASE_INPUT\");\r\n\r\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\r\n        // But May Happenï¼Œreserve >0 But totalSupply = 0\r\n        if (totalSupply == 0) {\r\n            // case 1. initial supply\r\n            shares = baseBalance; // ä»¥å…å‡ºçŽ°balanceå¾ˆå¤§ä½†shareså¾ˆå°çš„æƒ…å†µ\r\n            // require(_QUOTE_TARGET_ > 0, \"QUOTE_TARGET_IS_ZERO\");\r\n            require(shares > 2001, \"MINT_AMOUNT_NOT_ENOUGH\");\r\n            _mint(address(0), 1001);\r\n            shares -= 1001;\r\n        } else if (baseReserve > 0 && quoteReserve == 0) {\r\n            // case 2. supply when quote reserve is 0\r\n            shares = baseInput.mul(totalSupply).div(baseReserve);\r\n        } else if (baseReserve > 0 && quoteReserve > 0) {\r\n            // case 3. normal case\r\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\r\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\r\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\r\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\r\n        }\r\n        _mint(to, shares);\r\n        _setReserve(baseBalance, quoteBalance);\r\n        emit BuyShares(to, shares, _SHARES_[to]);\r\n    }\r\n\r\n    // sell shares [round down]\r\n    function sellShares(\r\n        uint256 shareAmount,\r\n        address to,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        bytes calldata data,\r\n        uint256 deadline\r\n    ) external preventReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\r\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\r\n        require(shareAmount <= _SHARES_[msg.sender], \"DLP_NOT_ENOUGH\");\r\n        require(to != address(this), \"SELL_BACK_NOT_ALLOWED\");\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 totalShares = totalSupply;\r\n\r\n        baseAmount = baseBalance.mul(shareAmount).div(totalShares);\r\n        quoteAmount = quoteBalance.mul(shareAmount).div(totalShares);\r\n\r\n        require(\r\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\r\n            \"WITHDRAW_NOT_ENOUGH\"\r\n        );\r\n\r\n        _burn(msg.sender, shareAmount);\r\n        _transferBaseOut(to, baseAmount);\r\n        _transferQuoteOut(to, quoteAmount);\r\n        _sync();\r\n\r\n        if (data.length > 0) {\r\n            IWorldesCallee(to).DVMSellShareCall(\r\n                msg.sender,\r\n                shareAmount,\r\n                baseAmount,\r\n                quoteAmount,\r\n                data\r\n            );\r\n        }\r\n\r\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\r\n    }\r\n}\r\n"
    },
    "contracts/vendingMachine/implements/DVMStorage.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {ReentrancyGuard} from \"../../libraries/ReentrancyGuard.sol\";\r\nimport {SafeMath} from \"../../libraries/SafeMath.sol\";\r\nimport {WorldesMath} from \"../../libraries/WorldesMath.sol\";\r\nimport {DecimalMath} from \"../../libraries/DecimalMath.sol\";\r\nimport {IFeeRateModel} from \"../../libraries/FeeRateModel.sol\";\r\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\r\nimport {PMMPricing} from \"../../libraries/PMMPricing.sol\";\r\n\r\ncontract DVMStorage is ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    bool public _IS_OPEN_TWAP_ = false;\r\n\r\n    bool internal _DVM_INITIALIZED_;\r\n\r\n    // ============ Core Address ============\r\n\r\n    address public _MAINTAINER_;\r\n\r\n    IERC20 public _BASE_TOKEN_;\r\n    IERC20 public _QUOTE_TOKEN_;\r\n\r\n    uint112 public _BASE_RESERVE_;\r\n    uint112 public _QUOTE_RESERVE_;\r\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\r\n\r\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\r\n\r\n    // ============ Shares (ERC20) ============\r\n\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    string public name;\r\n\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) internal _SHARES_;\r\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\r\n\r\n    // ================= Permit ======================\r\n\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint256) public nonces;\r\n\r\n    // ============ Variables for Pricing ============\r\n\r\n    uint256 public _LP_FEE_RATE_;\r\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\r\n    uint256 public _K_;\r\n    uint256 public _I_;\r\n\r\n\r\n    // ============ Helper Functions ============\r\n\r\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\r\n        state.i = _I_;\r\n        state.K = _K_;\r\n        state.B = _BASE_RESERVE_;\r\n        state.Q = _QUOTE_RESERVE_;\r\n        state.B0 = 0; // will be calculated in adjustedTarget\r\n        state.Q0 = 0;\r\n        state.R = PMMPricing.RState.ABOVE_ONE;\r\n        PMMPricing.adjustedTarget(state);\r\n    }\r\n\r\n    function getPMMStateForCall() \r\n        external \r\n        view \r\n        returns (\r\n            uint256 i,\r\n            uint256 K,\r\n            uint256 B,\r\n            uint256 Q,\r\n            uint256 B0,\r\n            uint256 Q0,\r\n            uint256 R\r\n        )\r\n    {\r\n        PMMPricing.PMMState memory state = getPMMState();\r\n        i = state.i;\r\n        K = state.K;\r\n        B = state.B;\r\n        Q = state.Q;\r\n        B0 = state.B0;\r\n        Q0 = state.Q0;\r\n        R = uint256(state.R);\r\n    }\r\n\r\n    function getMidPrice() public view returns (uint256 midPrice) {\r\n        return PMMPricing.getMidPrice(getPMMState());\r\n    }\r\n}\r\n"
    },
    "contracts/vendingMachine/implements/DVMTrader.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {DVMVault} from \"./DVMVault.sol\";\r\nimport {SafeMath} from \"../../libraries/SafeMath.sol\";\r\nimport {DecimalMath} from \"../../libraries/DecimalMath.sol\";\r\nimport {WorldesMath} from \"../../libraries/WorldesMath.sol\";\r\nimport {IWorldesCallee} from \"../../interfaces/IWorldesCallee.sol\";\r\nimport {PMMPricing} from \"../../libraries/PMMPricing.sol\";\r\n\r\ncontract DVMTrader is DVMVault {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Events ============\r\n\r\n    event WorldesSwap(\r\n        address fromToken,\r\n        address toToken,\r\n        uint256 fromAmount,\r\n        uint256 toAmount,\r\n        address trader,\r\n        address receiver\r\n    );\r\n\r\n    event WorldesFlashLoan(\r\n        address borrower,\r\n        address assetTo,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount\r\n    );\r\n\r\n    // ============ Trade Functions ============\r\n\r\n    function sellBase(address to)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 receiveQuoteAmount)\r\n    {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\r\n        uint256 mtFee;\r\n        (receiveQuoteAmount, mtFee) = querySellBase(tx.origin, baseInput);\r\n\r\n        _transferQuoteOut(to, receiveQuoteAmount);\r\n        _transferQuoteOut(_MAINTAINER_, mtFee);\r\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\r\n\r\n        emit WorldesSwap(\r\n            address(_BASE_TOKEN_),\r\n            address(_QUOTE_TOKEN_),\r\n            baseInput,\r\n            receiveQuoteAmount,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    function sellQuote(address to)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 receiveBaseAmount)\r\n    {\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\r\n        uint256 mtFee;\r\n        (receiveBaseAmount, mtFee) = querySellQuote(tx.origin, quoteInput);\r\n\r\n        _transferBaseOut(to, receiveBaseAmount);\r\n        _transferBaseOut(_MAINTAINER_, mtFee);\r\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\r\n\r\n        emit WorldesSwap(\r\n            address(_QUOTE_TOKEN_),\r\n            address(_BASE_TOKEN_),\r\n            quoteInput,\r\n            receiveBaseAmount,\r\n            msg.sender,\r\n            to\r\n        );\r\n    }\r\n\r\n    function flashLoan(\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        address assetTo,\r\n        bytes calldata data\r\n    ) external preventReentrant {\r\n        _transferBaseOut(assetTo, baseAmount);\r\n        _transferQuoteOut(assetTo, quoteAmount);\r\n\r\n        if (data.length > 0)\r\n            IWorldesCallee(assetTo).DVMFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\r\n\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        \r\n        // no input -> pure loss\r\n        require(\r\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\r\n            \"FLASH_LOAN_FAILED\"\r\n        );\r\n\r\n        // sell quote\r\n        if (baseBalance < _BASE_RESERVE_) {\r\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\r\n            (uint256 receiveBaseAmount, uint256 mtFee) = querySellQuote(tx.origin, quoteInput);\r\n            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, \"FLASH_LOAN_FAILED\");\r\n\r\n            _transferBaseOut(_MAINTAINER_, mtFee);\r\n            emit WorldesSwap(\r\n                address(_QUOTE_TOKEN_),\r\n                address(_BASE_TOKEN_),\r\n                quoteInput,\r\n                receiveBaseAmount,\r\n                msg.sender,\r\n                assetTo\r\n            );\r\n        }\r\n\r\n        // sell base\r\n        if (quoteBalance < _QUOTE_RESERVE_) {\r\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\r\n            (uint256 receiveQuoteAmount, uint256 mtFee) = querySellBase(tx.origin, baseInput);\r\n            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, \"FLASH_LOAN_FAILED\");\r\n\r\n            _transferQuoteOut(_MAINTAINER_, mtFee);\r\n            emit WorldesSwap(\r\n                address(_BASE_TOKEN_),\r\n                address(_QUOTE_TOKEN_),\r\n                baseInput,\r\n                receiveQuoteAmount,\r\n                msg.sender,\r\n                assetTo\r\n            );\r\n        }\r\n\r\n        _sync();\r\n        \r\n        emit WorldesFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\r\n    }\r\n\r\n    // ============ Query Functions ============\r\n\r\n    function querySellBase(address trader, uint256 payBaseAmount)\r\n        public\r\n        view\r\n        returns (uint256 receiveQuoteAmount, uint256 mtFee)\r\n    {\r\n        (receiveQuoteAmount, ) = PMMPricing.sellBaseToken(getPMMState(), payBaseAmount);\r\n\r\n        uint256 lpFeeRate = _LP_FEE_RATE_;\r\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\r\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\r\n        receiveQuoteAmount = receiveQuoteAmount\r\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\r\n            .sub(mtFee);\r\n    }\r\n\r\n    function querySellQuote(address trader, uint256 payQuoteAmount)\r\n        public\r\n        view\r\n        returns (uint256 receiveBaseAmount, uint256 mtFee)\r\n    {\r\n        (receiveBaseAmount, ) = PMMPricing.sellQuoteToken(getPMMState(), payQuoteAmount);\r\n\r\n        uint256 lpFeeRate = _LP_FEE_RATE_;\r\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\r\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\r\n        receiveBaseAmount = receiveBaseAmount\r\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\r\n            .sub(mtFee);\r\n    }\r\n}\r\n"
    },
    "contracts/vendingMachine/implements/DVMVault.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport {IERC20} from \"../../interfaces/IERC20.sol\";\r\nimport {SafeMath} from \"../../libraries/SafeMath.sol\";\r\nimport {DecimalMath} from \"../../libraries/DecimalMath.sol\";\r\nimport {SafeERC20} from \"../../libraries/SafeERC20.sol\";\r\nimport {DVMStorage} from \"./DVMStorage.sol\";\r\n\r\ncontract DVMVault is DVMStorage {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ============ Events ============\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    event Mint(address indexed user, uint256 value);\r\n\r\n    event Burn(address indexed user, uint256 value);\r\n\r\n    // ============ View Functions ============\r\n\r\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\r\n        baseReserve = _BASE_RESERVE_;\r\n        quoteReserve = _QUOTE_RESERVE_;\r\n    }\r\n\r\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\r\n        lpFeeRate = _LP_FEE_RATE_;\r\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\r\n    }\r\n\r\n    // ============ Asset In ============\r\n\r\n    function getBaseInput() public view returns (uint256 input) {\r\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\r\n    }\r\n\r\n    function getQuoteInput() public view returns (uint256 input) {\r\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\r\n    }\r\n\r\n    // ============ TWAP UPDATE ===========\r\n    \r\n    function _twapUpdate() internal {\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\r\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\r\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\r\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\r\n        }\r\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\r\n    }\r\n\r\n    // ============ Set States ============\r\n\r\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\r\n        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), \"OVERFLOW\");\r\n        _BASE_RESERVE_ = uint112(baseReserve);\r\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\r\n\r\n        if(_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n    function _sync() internal {\r\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\r\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\r\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\r\n        if (baseBalance != _BASE_RESERVE_) {\r\n            _BASE_RESERVE_ = uint112(baseBalance);\r\n        }\r\n        if (quoteBalance != _QUOTE_RESERVE_) {\r\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\r\n        }\r\n\r\n        if(_IS_OPEN_TWAP_) _twapUpdate();\r\n    }\r\n\r\n\r\n    function sync() external preventReentrant {\r\n        _sync();\r\n    }\r\n\r\n    // ============ Asset Out ============\r\n\r\n    function _transferBaseOut(address to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            _BASE_TOKEN_.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    function _transferQuoteOut(address to, uint256 amount) internal {\r\n        if (amount > 0) {\r\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    // ============ Shares (ERC20) ============\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param to The address to transfer to.\r\n     * @param amount The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        require(amount <= _SHARES_[msg.sender], \"BALANCE_NOT_ENOUGH\");\r\n\r\n        _SHARES_[msg.sender] = _SHARES_[msg.sender].sub(amount);\r\n        _SHARES_[to] = _SHARES_[to].add(amount);\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param owner The address to query the the balance of.\r\n     * @return balance An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance) {\r\n        return _SHARES_[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param amount uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        require(amount <= _SHARES_[from], \"BALANCE_NOT_ENOUGH\");\r\n        require(amount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\r\n\r\n        _SHARES_[from] = _SHARES_[from].sub(amount);\r\n        _SHARES_[to] = _SHARES_[to].add(amount);\r\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(amount);\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @param spender The address which will spend the funds.\r\n     * @param amount The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        _ALLOWED_[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _ALLOWED_[owner][spender];\r\n    }\r\n\r\n    function _mint(address user, uint256 value) internal {\r\n        require(value > 1000, \"MINT_INVALID\");\r\n        _SHARES_[user] = _SHARES_[user].add(value);\r\n        totalSupply = totalSupply.add(value);\r\n        emit Mint(user, value);\r\n        emit Transfer(address(0), user, value);\r\n    }\r\n\r\n    function _burn(address user, uint256 value) internal {\r\n        _SHARES_[user] = _SHARES_[user].sub(value);\r\n        totalSupply = totalSupply.sub(value);\r\n        emit Burn(user, value);\r\n        emit Transfer(user, address(0), value);\r\n    }\r\n\r\n    // ============================ Permit ======================================\r\n    \r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(deadline >= block.timestamp, \"DVM_LP: EXPIRED\");\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                \"\\x19\\x01\",\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(\r\n                    abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)\r\n                )\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(\r\n            recoveredAddress != address(0) && recoveredAddress == owner,\r\n            \"DVM_LP: INVALID_SIGNATURE\"\r\n        );\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n"
    },
    "contracts/vendingMachine/interfaces/IDVM.sol": {
      "content": "/*\r\n \r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface IDVM {\r\n    function init(\r\n        address maintainer,\r\n        address baseTokenAddress,\r\n        address quoteTokenAddress,\r\n        uint256 lpFeeRate,\r\n        address mtFeeRateModel,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external;\r\n\r\n    function _BASE_TOKEN_() external returns (address);\r\n\r\n    function _QUOTE_TOKEN_() external returns (address);\r\n\r\n    function _MT_FEE_RATE_MODEL_() external returns (address);\r\n\r\n    function getVaultReserve() external returns (uint256 baseReserve, uint256 quoteReserve);\r\n\r\n    function sellBase(address to) external returns (uint256);\r\n\r\n    function sellQuote(address to) external returns (uint256);\r\n\r\n    function buyShares(address to) external returns (uint256,uint256,uint256);\r\n\r\n    function addressToShortString(address _addr) external pure returns (string memory);\r\n\r\n    function getMidPrice() external view returns (uint256 midPrice);\r\n\r\n    function sellShares(\r\n        uint256 shareAmount,\r\n        address to,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        bytes calldata data,\r\n        uint256 deadline\r\n    ) external  returns (uint256 baseAmount, uint256 quoteAmount);\r\n\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}